/ entity.h (add these constants)
class Entity {
public:
    // Priority levels
    static constexpr int PRIORITY_CRITICAL = 100;  // Emergency (fire, combat, danger)
    static constexpr int PRIORITY_HIGH = 50;       // Assigned important tasks
    static constexpr int PRIORITY_NORMAL = 10;     // Regular work tasks
    static constexpr int PRIORITY_LOW = 5;         // Optional/background tasks
    static constexpr int PRIORITY_IDLE = 0;        // Wandering (always interruptible)
    
    // ... rest of class
};

// colonist.cpp
bool Colonist::simulate(EntitySimulationParam &params)
{
    if (!active) return false;
    
    move_timer -= params.delta;
    if (move_timer > 0.0f) return false;
    
    // Check if we should preempt the current job for a higher priority one
    bool should_switch_job = false;
    
    if (currentJobIndex != -1 && currentJobIndex < jobList.size())
    {
        EntityJob& current = jobList[currentJobIndex];
        
        // Find if there's a higher priority job available
        if (jobList.size() > 1) // Only check if there are alternatives
        {
            auto highest_it = std::max_element(jobList.begin(), jobList.end(),
                [](const EntityJob& a, const EntityJob& b) {
                    return a.priority < b.priority;
                });
            
            int highest_priority = highest_it->priority;
            
            // Preempt if current job is interruptible (priority 0) 
            // and there's a higher priority job available
            if (current.priority == PRIORITY_IDLE && highest_priority > PRIORITY_IDLE)
            {
                current.complete = true;
                should_switch_job = true;
            }
        }
    }
    
    // Clean up completed jobs
    jobList.erase(
        std::remove_if(jobList.begin(), jobList.end(),
            [](const EntityJob& j) { return j.complete; }),
        jobList.end()
    );
    
    // Invalidate index if out of range
    if (currentJobIndex >= jobList.size()) 
    { 
        currentJobIndex = -1; 
    }
    
    // Select a new job if needed
    if (currentJobIndex == -1 || should_switch_job)
    {
        if (!jobList.empty())
        {
            // Pick highest priority job
            auto it = std::max_element(jobList.begin(), jobList.end(),
                [](const EntityJob& a, const EntityJob& b) {
                    return a.priority < b.priority;
                });
            currentJobIndex = std::distance(jobList.begin(), it);
            update_move_speed_from_job(jobList[currentJobIndex]);
            reset_timer(); // Reset timer when starting a new job
        }
        else
        {
            // Create new wander job (idle priority - interruptible)
            EntityJob wander;
            wander.move_algo = "default";
            wander.priority = PRIORITY_IDLE; // Interruptible
            wander.moveSpeedMultiplier = 0.2f;
            
            thread_local static std::mt19937 gen(std::random_device{}());
            std::uniform_int_distribution<int> dist(0, 10);
            std::uniform_int_distribution<int> dir(0, 1);
            
            int fdir = dir(gen) == 0 ? -1 : 1;
            int distance = dist(gen) * fdir;
            
            wander.target_coord = {position.x + distance, position.y + distance};
            
            add_job(wander);
            currentJobIndex = jobList.size() - 1;
            update_move_speed_from_job(wander);
            reset_timer(); // Reset timer for new wander job
        }
    }
    
    // Execute movement for current job
    bool moved = false;
    if (currentJobIndex >= 0 && currentJobIndex < jobList.size())
    {
        EntityJob& current = jobList[currentJobIndex];
        
        if (current.move_algo == "default")
        {
            moved = default_movement(params);
        }
        else
        {
            moved = random_movement(params);
        }
        
        // Only reset timer if job completed naturally (not preempted)
        if (current.complete && !should_switch_job)
        {
            reset_timer();
        }
    }
    
    return moved;
}

// Example usage when creating jobs:

// High priority task (like hauling urgent materials)
EntityJob haul_job;
haul_job.priority = Entity::PRIORITY_HIGH;
haul_job.moveSpeedMultiplier = 1.5f; // Move faster for urgent tasks
haul_job.target_coord = storage_location;
colonist->add_job(haul_job);

// Normal work task
EntityJob build_job;
build_job.priority = Entity::PRIORITY_NORMAL;
build_job.moveSpeedMultiplier = 1.0f;
build_job.target_coord = construction_site;
colonist->add_job(build_job);

// Low priority task (like cleaning)
EntityJob clean_job;
clean_job.priority = Entity::PRIORITY_LOW;
clean_job.moveSpeedMultiplier = 0.8f;
clean_job.target_coord = dirty_area;
colonist->add_job(clean_job);

// Critical emergency (fire, combat)
EntityJob emergency_job;
emergency_job.priority = Entity::PRIORITY_CRITICAL;
emergency_job.moveSpeedMultiplier = 2.0f; // Move much faster in emergencies
emergency_job.target_coord = emergency_location;
colonist->add_job(emergency_job);
